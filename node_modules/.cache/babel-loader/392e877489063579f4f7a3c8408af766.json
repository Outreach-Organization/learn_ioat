{"ast":null,"code":"// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n'use strict';\n\nconst SortedSet = require('js-sdsl').OrderedSet;\n\nconst debugTrace = require('debug')('number-allocator:trace');\n\nconst debugError = require('debug')('number-allocator:error');\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\n\n\nfunction Interval(low, high) {\n  this.low = low;\n  this.high = high;\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high;\n};\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1;\n  if (other.low < this.low && other.high < this.low) return 1;\n  return 0;\n};\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\n\n\nfunction NumberAllocator(min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max);\n  }\n\n  this.min = min;\n  this.max = max;\n  this.ss = new SortedSet([], (lhs, rhs) => {\n    return lhs.compare(rhs);\n  });\n  debugTrace('Create');\n  this.clear();\n}\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\n\n\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null;\n  return this.ss.front().low;\n};\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\n\n\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty');\n    return null;\n  }\n\n  const it = this.ss.begin();\n  const low = it.pointer.low;\n  const high = it.pointer.high;\n  const num = low;\n\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.updateKeyByIterator(it, new Interval(low + 1, high));\n  } else {\n    this.ss.eraseElementByPos(0);\n  }\n\n  debugTrace('alloc():' + num);\n  return num;\n};\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\n\n\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low;\n    const high = it.pointer.high;\n\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it);\n      debugTrace('use():' + num);\n      return true;\n    } // x |-----|\n\n\n    if (low > num) return false; // |x----|\n\n    if (low === num) {\n      // x|----|\n      this.ss.updateKeyByIterator(it, new Interval(low + 1, high));\n      debugTrace('use():' + num);\n      return true;\n    } // |----x|\n\n\n    if (high === num) {\n      // |----|x\n      this.ss.updateKeyByIterator(it, new Interval(low, high - 1));\n      debugTrace('use():' + num);\n      return true;\n    } // |--x--|\n    // x|--|\n\n\n    this.ss.updateKeyByIterator(it, new Interval(num + 1, high)); // |--|x|--|\n\n    this.ss.insert(new Interval(low, num - 1));\n    debugTrace('use():' + num);\n    return true;\n  }\n\n  debugTrace('use():failed');\n  return false;\n};\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\n\n\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range');\n    return;\n  }\n\n  const key = new Interval(num, num);\n  const it = this.ss.upperBound(key);\n\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key);\n      return;\n    }\n\n    it.pre();\n    const low = it.pointer.high;\n    const high = it.pointer.high;\n\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.updateKeyByIterator(it, new Interval(low, num));\n    } else {\n      // Insert new interval\n      this.ss.insert(key);\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const high = it.pointer.high;\n        this.ss.updateKeyByIterator(it, new Interval(num, high));\n      } else {\n        // Insert new interval\n        this.ss.insert(key);\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low;\n      const rHigh = it.pointer.high;\n      it.pre();\n      const lLow = it.pointer.low;\n      const lHigh = it.pointer.high;\n\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it);\n          this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh));\n        } else {\n          // Concat to left\n          this.ss.updateKeyByIterator(it, new Interval(lLow, num));\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next());\n          this.ss.insert(new Interval(num, rHigh));\n        } else {\n          // Insert new interval\n          this.ss.insert(key);\n        }\n      }\n    }\n  }\n\n  debugTrace('free():' + num);\n};\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\n\n\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()');\n  this.ss.clear();\n  this.ss.insert(new Interval(this.min, this.max));\n};\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\n\n\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size();\n};\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\n\n\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size());\n\n  for (const element of this.ss) {\n    console.log(element);\n  }\n};\n\nmodule.exports = NumberAllocator;","map":{"version":3,"sources":["/home/sdn/learn_IoAT/node_modules/number-allocator/lib/number-allocator.js"],"names":["SortedSet","require","OrderedSet","debugTrace","debugError","Interval","low","high","prototype","equals","other","compare","NumberAllocator","min","max","ss","lhs","rhs","clear","firstVacant","size","front","alloc","it","begin","pointer","num","updateKeyByIterator","eraseElementByPos","use","key","lowerBound","end","eraseElementByIterator","insert","free","upperBound","pre","rLow","rHigh","lLow","lHigh","next","intervalCount","dump","console","log","element","module","exports"],"mappings":"AAAA;AACA;AACA;AAEA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBC,UAArC;;AACA,MAAMC,UAAU,GAAGF,OAAO,CAAC,OAAD,CAAP,CAAiB,wBAAjB,CAAnB;;AACA,MAAMG,UAAU,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,wBAAjB,CAAnB;AACA;;;;;;;;AAMA,SAASI,QAAT,CAAmBC,GAAnB,EAAwBC,IAAxB,EAA8B;AAC5B,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,IAAL,GAAYA,IAAZ;AACD;;AAEDF,QAAQ,CAACG,SAAT,CAAmBC,MAAnB,GAA4B,UAAUC,KAAV,EAAiB;AAC3C,SAAO,KAAKJ,GAAL,KAAaI,KAAK,CAACJ,GAAnB,IAA0B,KAAKC,IAAL,KAAcG,KAAK,CAACH,IAArD;AACD,CAFD;;AAIAF,QAAQ,CAACG,SAAT,CAAmBG,OAAnB,GAA6B,UAAUD,KAAV,EAAiB;AAC5C,MAAI,KAAKJ,GAAL,GAAWI,KAAK,CAACJ,GAAjB,IAAwB,KAAKC,IAAL,GAAYG,KAAK,CAACJ,GAA9C,EAAmD,OAAO,CAAC,CAAR;AACnD,MAAII,KAAK,CAACJ,GAAN,GAAY,KAAKA,GAAjB,IAAwBI,KAAK,CAACH,IAAN,GAAa,KAAKD,GAA9C,EAAmD,OAAO,CAAP;AACnD,SAAO,CAAP;AACD,CAJD;AAMA;;;;;;;;;;AAQA,SAASM,eAAT,CAA0BC,GAA1B,EAA+BC,GAA/B,EAAoC;AAClC,MAAI,EAAE,gBAAgBF,eAAlB,CAAJ,EAAwC;AACtC,WAAO,IAAIA,eAAJ,CAAoBC,GAApB,EAAyBC,GAAzB,CAAP;AACD;;AAED,OAAKD,GAAL,GAAWA,GAAX;AACA,OAAKC,GAAL,GAAWA,GAAX;AAEA,OAAKC,EAAL,GAAU,IAAIf,SAAJ,CACR,EADQ,EAER,CAACgB,GAAD,EAAMC,GAAN,KAAc;AACZ,WAAOD,GAAG,CAACL,OAAJ,CAAYM,GAAZ,CAAP;AACD,GAJO,CAAV;AAMAd,EAAAA,UAAU,CAAC,QAAD,CAAV;AACA,OAAKe,KAAL;AACD;AAED;;;;;;;;AAMAN,eAAe,CAACJ,SAAhB,CAA0BW,WAA1B,GAAwC,YAAY;AAClD,MAAI,KAAKJ,EAAL,CAAQK,IAAR,OAAmB,CAAvB,EAA0B,OAAO,IAAP;AAC1B,SAAO,KAAKL,EAAL,CAAQM,KAAR,GAAgBf,GAAvB;AACD,CAHD;AAKA;;;;;;;AAKAM,eAAe,CAACJ,SAAhB,CAA0Bc,KAA1B,GAAkC,YAAY;AAC5C,MAAI,KAAKP,EAAL,CAAQK,IAAR,OAAmB,CAAvB,EAA0B;AACxBjB,IAAAA,UAAU,CAAC,eAAD,CAAV;AACA,WAAO,IAAP;AACD;;AACD,QAAMoB,EAAE,GAAG,KAAKR,EAAL,CAAQS,KAAR,EAAX;AACA,QAAMlB,GAAG,GAAGiB,EAAE,CAACE,OAAH,CAAWnB,GAAvB;AACA,QAAMC,IAAI,GAAGgB,EAAE,CAACE,OAAH,CAAWlB,IAAxB;AACA,QAAMmB,GAAG,GAAGpB,GAAZ;;AACA,MAAIoB,GAAG,GAAG,CAAN,IAAWnB,IAAf,EAAqB;AACnB;AACA,SAAKQ,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAaC,GAAG,GAAG,CAAnB,EAAsBC,IAAtB,CAAhC;AACD,GAHD,MAGO;AACL,SAAKQ,EAAL,CAAQa,iBAAR,CAA0B,CAA1B;AACD;;AACDzB,EAAAA,UAAU,CAAC,aAAauB,GAAd,CAAV;AACA,SAAOA,GAAP;AACD,CAjBD;AAmBA;;;;;;;;;AAOAd,eAAe,CAACJ,SAAhB,CAA0BqB,GAA1B,GAAgC,UAAUH,GAAV,EAAe;AAC7C,QAAMI,GAAG,GAAG,IAAIzB,QAAJ,CAAaqB,GAAb,EAAkBA,GAAlB,CAAZ;AACA,QAAMH,EAAE,GAAG,KAAKR,EAAL,CAAQgB,UAAR,CAAmBD,GAAnB,CAAX;;AACA,MAAI,CAACP,EAAE,CAACd,MAAH,CAAU,KAAKM,EAAL,CAAQiB,GAAR,EAAV,CAAL,EAA+B;AAC7B,UAAM1B,GAAG,GAAGiB,EAAE,CAACE,OAAH,CAAWnB,GAAvB;AACA,UAAMC,IAAI,GAAGgB,EAAE,CAACE,OAAH,CAAWlB,IAAxB;;AACA,QAAIgB,EAAE,CAACE,OAAH,CAAWhB,MAAX,CAAkBqB,GAAlB,CAAJ,EAA4B;AAC1B;AACA,WAAKf,EAAL,CAAQkB,sBAAR,CAA+BV,EAA/B;AACApB,MAAAA,UAAU,CAAC,WAAWuB,GAAZ,CAAV;AACA,aAAO,IAAP;AACD,KAR4B,CAU7B;;;AACA,QAAIpB,GAAG,GAAGoB,GAAV,EAAe,OAAO,KAAP,CAXc,CAa7B;;AACA,QAAIpB,GAAG,KAAKoB,GAAZ,EAAiB;AACf;AACA,WAAKX,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAaC,GAAG,GAAG,CAAnB,EAAsBC,IAAtB,CAAhC;AACAJ,MAAAA,UAAU,CAAC,WAAWuB,GAAZ,CAAV;AACA,aAAO,IAAP;AACD,KAnB4B,CAqB7B;;;AACA,QAAInB,IAAI,KAAKmB,GAAb,EAAkB;AAChB;AACA,WAAKX,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAaC,GAAb,EAAkBC,IAAI,GAAG,CAAzB,CAAhC;AACAJ,MAAAA,UAAU,CAAC,WAAWuB,GAAZ,CAAV;AACA,aAAO,IAAP;AACD,KA3B4B,CA6B7B;AACA;;;AACA,SAAKX,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAaqB,GAAG,GAAG,CAAnB,EAAsBnB,IAAtB,CAAhC,EA/B6B,CAgC7B;;AACA,SAAKQ,EAAL,CAAQmB,MAAR,CAAe,IAAI7B,QAAJ,CAAaC,GAAb,EAAkBoB,GAAG,GAAG,CAAxB,CAAf;AACAvB,IAAAA,UAAU,CAAC,WAAWuB,GAAZ,CAAV;AACA,WAAO,IAAP;AACD;;AAEDvB,EAAAA,UAAU,CAAC,cAAD,CAAV;AACA,SAAO,KAAP;AACD,CA3CD;AA6CA;;;;;;;;AAMAS,eAAe,CAACJ,SAAhB,CAA0B2B,IAA1B,GAAiC,UAAUT,GAAV,EAAe;AAC9C,MAAIA,GAAG,GAAG,KAAKb,GAAX,IAAkBa,GAAG,GAAG,KAAKZ,GAAjC,EAAsC;AACpCV,IAAAA,UAAU,CAAC,YAAYsB,GAAZ,GAAkB,kBAAnB,CAAV;AACA;AACD;;AACD,QAAMI,GAAG,GAAG,IAAIzB,QAAJ,CAAaqB,GAAb,EAAkBA,GAAlB,CAAZ;AACA,QAAMH,EAAE,GAAG,KAAKR,EAAL,CAAQqB,UAAR,CAAmBN,GAAnB,CAAX;;AACA,MAAIP,EAAE,CAACd,MAAH,CAAU,KAAKM,EAAL,CAAQiB,GAAR,EAAV,CAAJ,EAA8B;AAC5B;AACA,QAAIT,EAAE,CAACd,MAAH,CAAU,KAAKM,EAAL,CAAQS,KAAR,EAAV,CAAJ,EAAgC;AAC9B;AACA,WAAKT,EAAL,CAAQmB,MAAR,CAAeJ,GAAf;AACA;AACD;;AACDP,IAAAA,EAAE,CAACc,GAAH;AACA,UAAM/B,GAAG,GAAGiB,EAAE,CAACE,OAAH,CAAWlB,IAAvB;AACA,UAAMA,IAAI,GAAGgB,EAAE,CAACE,OAAH,CAAWlB,IAAxB;;AACA,QAAIA,IAAI,GAAG,CAAP,KAAamB,GAAjB,EAAsB;AACpB;AACA,WAAKX,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAaC,GAAb,EAAkBoB,GAAlB,CAAhC;AACD,KAHD,MAGO;AACL;AACA,WAAKX,EAAL,CAAQmB,MAAR,CAAeJ,GAAf;AACD;AACF,GAjBD,MAiBO;AACL,QAAIP,EAAE,CAACd,MAAH,CAAU,KAAKM,EAAL,CAAQS,KAAR,EAAV,CAAJ,EAAgC;AAC9B;AACA,UAAIE,GAAG,GAAG,CAAN,KAAYH,EAAE,CAACE,OAAH,CAAWnB,GAA3B,EAAgC;AAC9B;AACA,cAAMC,IAAI,GAAGgB,EAAE,CAACE,OAAH,CAAWlB,IAAxB;AACA,aAAKQ,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAaqB,GAAb,EAAkBnB,IAAlB,CAAhC;AACD,OAJD,MAIO;AACL;AACA,aAAKQ,EAAL,CAAQmB,MAAR,CAAeJ,GAAf;AACD;AACF,KAVD,MAUO;AACL;AACA,YAAMQ,IAAI,GAAGf,EAAE,CAACE,OAAH,CAAWnB,GAAxB;AACA,YAAMiC,KAAK,GAAGhB,EAAE,CAACE,OAAH,CAAWlB,IAAzB;AACAgB,MAAAA,EAAE,CAACc,GAAH;AACA,YAAMG,IAAI,GAAGjB,EAAE,CAACE,OAAH,CAAWnB,GAAxB;AACA,YAAMmC,KAAK,GAAGlB,EAAE,CAACE,OAAH,CAAWlB,IAAzB;;AACA,UAAIkC,KAAK,GAAG,CAAR,KAAcf,GAAlB,EAAuB;AACrB,YAAIA,GAAG,GAAG,CAAN,KAAYY,IAAhB,EAAsB;AACpB;AACA,eAAKvB,EAAL,CAAQkB,sBAAR,CAA+BV,EAA/B;AACA,eAAKR,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAamC,IAAb,EAAmBD,KAAnB,CAAhC;AACD,SAJD,MAIO;AACL;AACA,eAAKxB,EAAL,CAAQY,mBAAR,CAA4BJ,EAA5B,EAAgC,IAAIlB,QAAJ,CAAamC,IAAb,EAAmBd,GAAnB,CAAhC;AACD;AACF,OATD,MASO;AACL,YAAIA,GAAG,GAAG,CAAN,KAAYY,IAAhB,EAAsB;AACpB;AACA,eAAKvB,EAAL,CAAQkB,sBAAR,CAA+BV,EAAE,CAACmB,IAAH,EAA/B;AACA,eAAK3B,EAAL,CAAQmB,MAAR,CAAe,IAAI7B,QAAJ,CAAaqB,GAAb,EAAkBa,KAAlB,CAAf;AACD,SAJD,MAIO;AACL;AACA,eAAKxB,EAAL,CAAQmB,MAAR,CAAeJ,GAAf;AACD;AACF;AACF;AACF;;AACD3B,EAAAA,UAAU,CAAC,YAAYuB,GAAb,CAAV;AACD,CAhED;AAkEA;;;;;;;AAKAd,eAAe,CAACJ,SAAhB,CAA0BU,KAA1B,GAAkC,YAAY;AAC5Cf,EAAAA,UAAU,CAAC,SAAD,CAAV;AACA,OAAKY,EAAL,CAAQG,KAAR;AACA,OAAKH,EAAL,CAAQmB,MAAR,CAAe,IAAI7B,QAAJ,CAAa,KAAKQ,GAAlB,EAAuB,KAAKC,GAA5B,CAAf;AACD,CAJD;AAMA;;;;;;;;AAMAF,eAAe,CAACJ,SAAhB,CAA0BmC,aAA1B,GAA0C,YAAY;AACpD,SAAO,KAAK5B,EAAL,CAAQK,IAAR,EAAP;AACD,CAFD;AAIA;;;;;;;AAKAR,eAAe,CAACJ,SAAhB,CAA0BoC,IAA1B,GAAiC,YAAY;AAC3CC,EAAAA,OAAO,CAACC,GAAR,CAAY,YAAY,KAAK/B,EAAL,CAAQK,IAAR,EAAxB;;AACA,OAAK,MAAM2B,OAAX,IAAsB,KAAKhC,EAA3B,EAA+B;AAC7B8B,IAAAA,OAAO,CAACC,GAAR,CAAYC,OAAZ;AACD;AACF,CALD;;AAOAC,MAAM,CAACC,OAAP,GAAiBrC,eAAjB","sourcesContent":["// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n'use strict'\n\nconst SortedSet = require('js-sdsl').OrderedSet\nconst debugTrace = require('debug')('number-allocator:trace')\nconst debugError = require('debug')('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.begin()\n  const low = it.pointer.low\n  const high = it.pointer.high\n  const num = low\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low\n    const high = it.pointer.high\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (low > num) return false\n\n    // |x----|\n    if (low === num) {\n      // x|----|\n      this.ss.updateKeyByIterator(it, new Interval(low + 1, high))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (high === num) {\n      // |----|x\n      this.ss.updateKeyByIterator(it, new Interval(low, high - 1))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |--x--|\n    // x|--|\n    this.ss.updateKeyByIterator(it, new Interval(num + 1, high))\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.upperBound(key)\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    it.pre()\n    const low = it.pointer.high\n    const high = it.pointer.high\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.updateKeyByIterator(it, new Interval(low, num))\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const high = it.pointer.high\n        this.ss.updateKeyByIterator(it, new Interval(num, high))\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low\n      const rHigh = it.pointer.high\n      it.pre()\n      const lLow = it.pointer.low\n      const lHigh = it.pointer.high\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it)\n          this.ss.updateKeyByIterator(it, new Interval(lLow, rHigh))\n        } else {\n          // Concat to left\n          this.ss.updateKeyByIterator(it, new Interval(lLow, num))\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next())\n          this.ss.insert(new Interval(num, rHigh))\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n"]},"metadata":{},"sourceType":"script"}