{"ast":null,"code":"var __extends = this && this.t || function () {\n  var extendStatics = function (e, r) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (e, r) {\n      e.__proto__ = r;\n    } || function (e, r) {\n      for (var i in r) if (Object.prototype.hasOwnProperty.call(r, i)) e[i] = r[i];\n    };\n\n    return extendStatics(e, r);\n  };\n\n  return function (e, r) {\n    if (typeof r !== \"function\" && r !== null) throw new TypeError(\"Class extends value \" + String(r) + \" is not a constructor or null\");\n    extendStatics(e, r);\n\n    function __() {\n      this.constructor = e;\n    }\n\n    e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());\n  };\n}();\n\nvar __read = this && this.q || function (e, r) {\n  var i = typeof Symbol === \"function\" && e[Symbol.iterator];\n  if (!i) return e;\n  var t = i.call(e),\n      n,\n      s = [],\n      f;\n\n  try {\n    while ((r === void 0 || r-- > 0) && !(n = t.next()).done) s.push(n.value);\n  } catch (e) {\n    f = {\n      error: e\n    };\n  } finally {\n    try {\n      if (n && !n.done && (i = t[\"return\"])) i.call(t);\n    } finally {\n      if (f) throw f.error;\n    }\n  }\n\n  return s;\n};\n\nvar __values = this && this.V || function (e) {\n  var r = typeof Symbol === \"function\" && Symbol.iterator,\n      i = r && e[r],\n      t = 0;\n  if (i) return i.call(e);\n  if (e && typeof e.length === \"number\") return {\n    next: function () {\n      if (e && t >= e.length) e = void 0;\n      return {\n        value: e && e[t++],\n        done: !e\n      };\n    }\n  };\n  throw new TypeError(r ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport { TreeNode, TreeNodeEnableIndex } from \"./TreeNode\";\nimport { Container } from \"../../ContainerBase\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\n\nvar TreeContainer = function (e) {\n  __extends(TreeContainer, e);\n\n  function TreeContainer(r, i) {\n    if (r === void 0) {\n      r = function (e, r) {\n        if (e < r) return -1;\n        if (e > r) return 1;\n        return 0;\n      };\n    }\n\n    if (i === void 0) {\n      i = false;\n    }\n\n    var t = e.call(this) || this;\n    t.W = undefined;\n    t.$ = r;\n\n    if (i) {\n      t.re = TreeNodeEnableIndex;\n\n      t.v = function (e, r, i) {\n        var t = this.se(e, r, i);\n\n        if (t) {\n          var n = t.rr;\n\n          while (n !== this.h) {\n            n.tr += 1;\n            n = n.rr;\n          }\n\n          var s = this.fe(t);\n\n          if (s) {\n            var f = s,\n                h = f.parentNode,\n                u = f.grandParent,\n                a = f.curNode;\n            h.ie();\n            u.ie();\n            a.ie();\n          }\n        }\n\n        return this.M;\n      };\n\n      t.G = function (e) {\n        var r = this.he(e);\n\n        while (r !== this.h) {\n          r.tr -= 1;\n          r = r.rr;\n        }\n      };\n    } else {\n      t.re = TreeNode;\n\n      t.v = function (e, r, i) {\n        var t = this.se(e, r, i);\n        if (t) this.fe(t);\n        return this.M;\n      };\n\n      t.G = t.he;\n    }\n\n    t.h = new t.re();\n    return t;\n  }\n\n  TreeContainer.prototype.U = function (e, r) {\n    var i = this.h;\n\n    while (e) {\n      var t = this.$(e.u, r);\n\n      if (t < 0) {\n        e = e.N;\n      } else if (t > 0) {\n        i = e;\n        e = e.K;\n      } else return e;\n    }\n\n    return i;\n  };\n\n  TreeContainer.prototype.X = function (e, r) {\n    var i = this.h;\n\n    while (e) {\n      var t = this.$(e.u, r);\n\n      if (t <= 0) {\n        e = e.N;\n      } else {\n        i = e;\n        e = e.K;\n      }\n    }\n\n    return i;\n  };\n\n  TreeContainer.prototype.Y = function (e, r) {\n    var i = this.h;\n\n    while (e) {\n      var t = this.$(e.u, r);\n\n      if (t < 0) {\n        i = e;\n        e = e.N;\n      } else if (t > 0) {\n        e = e.K;\n      } else return e;\n    }\n\n    return i;\n  };\n\n  TreeContainer.prototype.Z = function (e, r) {\n    var i = this.h;\n\n    while (e) {\n      var t = this.$(e.u, r);\n\n      if (t < 0) {\n        i = e;\n        e = e.N;\n      } else {\n        e = e.K;\n      }\n    }\n\n    return i;\n  };\n\n  TreeContainer.prototype.ue = function (e) {\n    while (true) {\n      var r = e.rr;\n      if (r === this.h) return;\n\n      if (e.ee === 1) {\n        e.ee = 0;\n        return;\n      }\n\n      if (e === r.K) {\n        var i = r.N;\n\n        if (i.ee === 1) {\n          i.ee = 0;\n          r.ee = 1;\n\n          if (r === this.W) {\n            this.W = r.ne();\n          } else r.ne();\n        } else {\n          if (i.N && i.N.ee === 1) {\n            i.ee = r.ee;\n            r.ee = 0;\n            i.N.ee = 0;\n\n            if (r === this.W) {\n              this.W = r.ne();\n            } else r.ne();\n\n            return;\n          } else if (i.K && i.K.ee === 1) {\n            i.ee = 1;\n            i.K.ee = 0;\n            i.te();\n          } else {\n            i.ee = 1;\n            e = r;\n          }\n        }\n      } else {\n        var i = r.K;\n\n        if (i.ee === 1) {\n          i.ee = 0;\n          r.ee = 1;\n\n          if (r === this.W) {\n            this.W = r.te();\n          } else r.te();\n        } else {\n          if (i.K && i.K.ee === 1) {\n            i.ee = r.ee;\n            r.ee = 0;\n            i.K.ee = 0;\n\n            if (r === this.W) {\n              this.W = r.te();\n            } else r.te();\n\n            return;\n          } else if (i.N && i.N.ee === 1) {\n            i.ee = 1;\n            i.N.ee = 0;\n            i.ne();\n          } else {\n            i.ee = 1;\n            e = r;\n          }\n        }\n      }\n    }\n  };\n\n  TreeContainer.prototype.he = function (e) {\n    var r, i;\n\n    if (this.M === 1) {\n      this.clear();\n      return this.h;\n    }\n\n    var t = e;\n\n    while (t.K || t.N) {\n      if (t.N) {\n        t = t.N;\n\n        while (t.K) t = t.K;\n      } else {\n        t = t.K;\n      }\n\n      r = __read([t.u, e.u], 2), e.u = r[0], t.u = r[1];\n      i = __read([t.p, e.p], 2), e.p = i[0], t.p = i[1];\n      e = t;\n    }\n\n    if (this.h.K === t) {\n      this.h.K = t.rr;\n    } else if (this.h.N === t) {\n      this.h.N = t.rr;\n    }\n\n    this.ue(t);\n    var n = t.rr;\n\n    if (t === n.K) {\n      n.K = undefined;\n    } else n.N = undefined;\n\n    this.M -= 1;\n    this.W.ee = 0;\n    return n;\n  };\n\n  TreeContainer.prototype.ae = function (e, r) {\n    if (e === undefined) return false;\n    var i = this.ae(e.K, r);\n    if (i) return true;\n    if (r(e)) return true;\n    return this.ae(e.N, r);\n  };\n\n  TreeContainer.prototype.fe = function (e) {\n    while (true) {\n      var r = e.rr;\n      if (r.ee === 0) return;\n      var i = r.rr;\n\n      if (r === i.K) {\n        var t = i.N;\n\n        if (t && t.ee === 1) {\n          t.ee = r.ee = 0;\n          if (i === this.W) return;\n          i.ee = 1;\n          e = i;\n          continue;\n        } else if (e === r.N) {\n          e.ee = 0;\n          if (e.K) e.K.rr = r;\n          if (e.N) e.N.rr = i;\n          r.N = e.K;\n          i.K = e.N;\n          e.K = r;\n          e.N = i;\n\n          if (i === this.W) {\n            this.W = e;\n            this.h.rr = e;\n          } else {\n            var n = i.rr;\n\n            if (n.K === i) {\n              n.K = e;\n            } else n.N = e;\n          }\n\n          e.rr = i.rr;\n          r.rr = e;\n          i.rr = e;\n          i.ee = 1;\n          return {\n            parentNode: r,\n            grandParent: i,\n            curNode: e\n          };\n        } else {\n          r.ee = 0;\n\n          if (i === this.W) {\n            this.W = i.te();\n          } else i.te();\n\n          i.ee = 1;\n        }\n      } else {\n        var t = i.K;\n\n        if (t && t.ee === 1) {\n          t.ee = r.ee = 0;\n          if (i === this.W) return;\n          i.ee = 1;\n          e = i;\n          continue;\n        } else if (e === r.K) {\n          e.ee = 0;\n          if (e.K) e.K.rr = i;\n          if (e.N) e.N.rr = r;\n          i.N = e.K;\n          r.K = e.N;\n          e.K = i;\n          e.N = r;\n\n          if (i === this.W) {\n            this.W = e;\n            this.h.rr = e;\n          } else {\n            var n = i.rr;\n\n            if (n.K === i) {\n              n.K = e;\n            } else n.N = e;\n          }\n\n          e.rr = i.rr;\n          r.rr = e;\n          i.rr = e;\n          i.ee = 1;\n          return {\n            parentNode: r,\n            grandParent: i,\n            curNode: e\n          };\n        } else {\n          r.ee = 0;\n\n          if (i === this.W) {\n            this.W = i.ne();\n          } else i.ne();\n\n          i.ee = 1;\n        }\n      }\n\n      return;\n    }\n  };\n\n  TreeContainer.prototype.se = function (e, r, i) {\n    if (this.W === undefined) {\n      this.M += 1;\n      this.W = new this.re(e, r);\n      this.W.ee = 0;\n      this.W.rr = this.h;\n      this.h.rr = this.W;\n      this.h.K = this.W;\n      this.h.N = this.W;\n      return;\n    }\n\n    var t;\n    var n = this.h.K;\n    var s = this.$(n.u, e);\n\n    if (s === 0) {\n      n.p = r;\n      return;\n    } else if (s > 0) {\n      n.K = new this.re(e, r);\n      n.K.rr = n;\n      t = n.K;\n      this.h.K = t;\n    } else {\n      var f = this.h.N;\n      var h = this.$(f.u, e);\n\n      if (h === 0) {\n        f.p = r;\n        return;\n      } else if (h < 0) {\n        f.N = new this.re(e, r);\n        f.N.rr = f;\n        t = f.N;\n        this.h.N = t;\n      } else {\n        if (i !== undefined) {\n          var u = i.o;\n\n          if (u !== this.h) {\n            var a = this.$(u.u, e);\n\n            if (a === 0) {\n              u.p = r;\n              return;\n            } else if (a > 0) {\n              var o = u.L();\n              var l = this.$(o.u, e);\n\n              if (l === 0) {\n                o.p = r;\n                return;\n              } else if (l < 0) {\n                t = new this.re(e, r);\n\n                if (o.N === undefined) {\n                  o.N = t;\n                  t.rr = o;\n                } else {\n                  u.K = t;\n                  t.rr = u;\n                }\n              }\n            }\n          }\n        }\n\n        if (t === undefined) {\n          t = this.W;\n\n          while (true) {\n            var v = this.$(t.u, e);\n\n            if (v > 0) {\n              if (t.K === undefined) {\n                t.K = new this.re(e, r);\n                t.K.rr = t;\n                t = t.K;\n                break;\n              }\n\n              t = t.K;\n            } else if (v < 0) {\n              if (t.N === undefined) {\n                t.N = new this.re(e, r);\n                t.N.rr = t;\n                t = t.N;\n                break;\n              }\n\n              t = t.N;\n            } else {\n              t.p = r;\n              return;\n            }\n          }\n        }\n      }\n    }\n\n    this.M += 1;\n    return t;\n  };\n\n  TreeContainer.prototype.g = function (e, r) {\n    while (e) {\n      var i = this.$(e.u, r);\n\n      if (i < 0) {\n        e = e.N;\n      } else if (i > 0) {\n        e = e.K;\n      } else return e;\n    }\n\n    return e || this.h;\n  };\n\n  TreeContainer.prototype.clear = function () {\n    this.M = 0;\n    this.W = undefined;\n    this.h.rr = undefined;\n    this.h.K = this.h.N = undefined;\n  };\n\n  TreeContainer.prototype.updateKeyByIterator = function (e, r) {\n    var i = e.o;\n\n    if (i === this.h) {\n      throwIteratorAccessError();\n    }\n\n    if (this.M === 1) {\n      i.u = r;\n      return true;\n    }\n\n    if (i === this.h.K) {\n      if (this.$(i.m().u, r) > 0) {\n        i.u = r;\n        return true;\n      }\n\n      return false;\n    }\n\n    if (i === this.h.N) {\n      if (this.$(i.L().u, r) < 0) {\n        i.u = r;\n        return true;\n      }\n\n      return false;\n    }\n\n    var t = i.L().u;\n    if (this.$(t, r) >= 0) return false;\n    var n = i.m().u;\n    if (this.$(n, r) <= 0) return false;\n    i.u = r;\n    return true;\n  };\n\n  TreeContainer.prototype.eraseElementByPos = function (e) {\n    if (e < 0 || e > this.M - 1) {\n      throw new RangeError();\n    }\n\n    var r = 0;\n    var i = this;\n    this.ae(this.W, function (t) {\n      if (e === r) {\n        i.G(t);\n        return true;\n      }\n\n      r += 1;\n      return false;\n    });\n    return this.M;\n  };\n\n  TreeContainer.prototype.eraseElementByKey = function (e) {\n    if (this.M === 0) return false;\n    var r = this.g(this.W, e);\n    if (r === this.h) return false;\n    this.G(r);\n    return true;\n  };\n\n  TreeContainer.prototype.eraseElementByIterator = function (e) {\n    var r = e.o;\n\n    if (r === this.h) {\n      throwIteratorAccessError();\n    }\n\n    var i = r.N === undefined;\n    var t = e.iteratorType === 0;\n\n    if (t) {\n      if (i) e.next();\n    } else {\n      if (!i || r.K === undefined) e.next();\n    }\n\n    this.G(r);\n    return e;\n  };\n\n  TreeContainer.prototype.forEach = function (e) {\n    var r, i;\n    var t = 0;\n\n    try {\n      for (var n = __values(this), s = n.next(); !s.done; s = n.next()) {\n        var f = s.value;\n        e(f, t++, this);\n      }\n    } catch (e) {\n      r = {\n        error: e\n      };\n    } finally {\n      try {\n        if (s && !s.done && (i = n.return)) i.call(n);\n      } finally {\n        if (r) throw r.error;\n      }\n    }\n  };\n\n  TreeContainer.prototype.getElementByPos = function (e) {\n    var r, i;\n\n    if (e < 0 || e > this.M - 1) {\n      throw new RangeError();\n    }\n\n    var t;\n    var n = 0;\n\n    try {\n      for (var s = __values(this), f = s.next(); !f.done; f = s.next()) {\n        var h = f.value;\n\n        if (n === e) {\n          t = h;\n          break;\n        }\n\n        n += 1;\n      }\n    } catch (e) {\n      r = {\n        error: e\n      };\n    } finally {\n      try {\n        if (f && !f.done && (i = s.return)) i.call(s);\n      } finally {\n        if (r) throw r.error;\n      }\n    }\n\n    return t;\n  };\n\n  TreeContainer.prototype.getHeight = function () {\n    if (this.M === 0) return 0;\n\n    var traversal = function (e) {\n      if (!e) return 0;\n      return Math.max(traversal(e.K), traversal(e.N)) + 1;\n    };\n\n    return traversal(this.W);\n  };\n\n  return TreeContainer;\n}(Container);\n\nexport default TreeContainer;","map":{"version":3,"sources":["container/TreeContainer/Base/index.js","../../src/container/TreeContainer/Base/index.ts"],"names":["__extends","this","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","__read","o","n","m","Symbol","iterator","i","r","ar","e","next","done","push","value","error","__values","s","length","_this","_a","_b","e_1","e_1_1","_c","return","e_2","e_2_1","TreeNode","TreeNodeEnableIndex","Container","throwIteratorAccessError","RangeError","undefined","x","y","_super","_cmp","cmp","enableIndex","_TreeNodeClass","_set","key","hint","curNode","_preSet","_parent","_header","_subTreeSize","nodeList","_insertNodeSelfBalance","parentNode","grandParent","curNode_1","_recount","_length","_eraseNode","_preEraseNode","TreeContainer","resNode","cmpResult","_key","_right","_left","_color","brother","_root","_rotateLeft","_rotateRight","clear","swapNode","_value","_eraseNodeSelfBalance","callback","ifReturn","_inOrderTraversal","uncle","GP","minNode","compareToMin","maxNode","compareToMax","iterNode","_node","iterCmpRes","preNode","_pre","preCmpRes","iter","node","_next","preKey","nextKey","pos","index","self","_findElementNode","hasNoRight","isNormal","iteratorType","element","res","traversal","Math","max"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { TreeNode, TreeNodeEnableIndex } from './TreeNode';\nimport { Container } from \"../../ContainerBase\";\nimport $checkWithinAccessParams from \"../../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = /** @class */ (function (_super) {\n    __extends(TreeContainer, _super);\n    /**\n     * @internal\n     */\n    function TreeContainer(cmp, enableIndex) {\n        if (cmp === void 0) { cmp = function (x, y) {\n            if (x < y)\n                return -1;\n            if (x > y)\n                return 1;\n            return 0;\n        }; }\n        if (enableIndex === void 0) { enableIndex = false; }\n        var _this = _super.call(this) || this;\n        /**\n         * @internal\n         */\n        _this._root = undefined;\n        _this._cmp = cmp;\n        if (enableIndex) {\n            _this._TreeNodeClass = TreeNodeEnableIndex;\n            _this._set = function (key, value, hint) {\n                var curNode = this._preSet(key, value, hint);\n                if (curNode) {\n                    var p = curNode._parent;\n                    while (p !== this._header) {\n                        p._subTreeSize += 1;\n                        p = p._parent;\n                    }\n                    var nodeList = this._insertNodeSelfBalance(curNode);\n                    if (nodeList) {\n                        var _a = nodeList, parentNode = _a.parentNode, grandParent = _a.grandParent, curNode_1 = _a.curNode;\n                        parentNode._recount();\n                        grandParent._recount();\n                        curNode_1._recount();\n                    }\n                }\n                return this._length;\n            };\n            _this._eraseNode = function (curNode) {\n                var p = this._preEraseNode(curNode);\n                while (p !== this._header) {\n                    p._subTreeSize -= 1;\n                    p = p._parent;\n                }\n            };\n        }\n        else {\n            _this._TreeNodeClass = TreeNode;\n            _this._set = function (key, value, hint) {\n                var curNode = this._preSet(key, value, hint);\n                if (curNode)\n                    this._insertNodeSelfBalance(curNode);\n                return this._length;\n            };\n            _this._eraseNode = _this._preEraseNode;\n        }\n        _this._header = new _this._TreeNodeClass();\n        return _this;\n    }\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._lowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._upperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode._right;\n            }\n            else {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else {\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode === this._header)\n                return;\n            if (curNode._color === 1 /* TreeNodeColor.RED */) {\n                curNode._color = 0 /* TreeNodeColor.BLACK */;\n                return;\n            }\n            if (curNode === parentNode._left) {\n                var brother = parentNode._right;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateLeft();\n                    }\n                    else\n                        parentNode._rotateLeft();\n                }\n                else {\n                    if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateLeft();\n                        }\n                        else\n                            parentNode._rotateLeft();\n                        return;\n                    }\n                    else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateRight();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                var brother = parentNode._left;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateRight();\n                    }\n                    else\n                        parentNode._rotateRight();\n                }\n                else {\n                    if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateRight();\n                        }\n                        else\n                            parentNode._rotateRight();\n                        return;\n                    }\n                    else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateLeft();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._preEraseNode = function (curNode) {\n        var _a, _b;\n        if (this._length === 1) {\n            this.clear();\n            return this._header;\n        }\n        var swapNode = curNode;\n        while (swapNode._left || swapNode._right) {\n            if (swapNode._right) {\n                swapNode = swapNode._right;\n                while (swapNode._left)\n                    swapNode = swapNode._left;\n            }\n            else {\n                swapNode = swapNode._left;\n            }\n            _a = __read([swapNode._key, curNode._key], 2), curNode._key = _a[0], swapNode._key = _a[1];\n            _b = __read([swapNode._value, curNode._value], 2), curNode._value = _b[0], swapNode._value = _b[1];\n            curNode = swapNode;\n        }\n        if (this._header._left === swapNode) {\n            this._header._left = swapNode._parent;\n        }\n        else if (this._header._right === swapNode) {\n            this._header._right = swapNode._parent;\n        }\n        this._eraseNodeSelfBalance(swapNode);\n        var _parent = swapNode._parent;\n        if (swapNode === _parent._left) {\n            _parent._left = undefined;\n        }\n        else\n            _parent._right = undefined;\n        this._length -= 1;\n        this._root._color = 0 /* TreeNodeColor.BLACK */;\n        return _parent;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._inOrderTraversal = function (curNode, callback) {\n        if (curNode === undefined)\n            return false;\n        var ifReturn = this._inOrderTraversal(curNode._left, callback);\n        if (ifReturn)\n            return true;\n        if (callback(curNode))\n            return true;\n        return this._inOrderTraversal(curNode._right, callback);\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode._color === 0 /* TreeNodeColor.BLACK */)\n                return;\n            var grandParent = parentNode._parent;\n            if (parentNode === grandParent._left) {\n                var uncle = grandParent._right;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._right) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left)\n                        curNode._left._parent = parentNode;\n                    if (curNode._right)\n                        curNode._right._parent = grandParent;\n                    parentNode._right = curNode._left;\n                    grandParent._left = curNode._right;\n                    curNode._left = parentNode;\n                    curNode._right = grandParent;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return { parentNode: parentNode, grandParent: grandParent, curNode: curNode };\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateRight();\n                    }\n                    else\n                        grandParent._rotateRight();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n            }\n            else {\n                var uncle = grandParent._left;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._left) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left)\n                        curNode._left._parent = grandParent;\n                    if (curNode._right)\n                        curNode._right._parent = parentNode;\n                    grandParent._right = curNode._left;\n                    parentNode._left = curNode._right;\n                    curNode._left = grandParent;\n                    curNode._right = parentNode;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return { parentNode: parentNode, grandParent: grandParent, curNode: curNode };\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateLeft();\n                    }\n                    else\n                        grandParent._rotateLeft();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n            }\n            return;\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._preSet = function (key, value, hint) {\n        if (this._root === undefined) {\n            this._length += 1;\n            this._root = new this._TreeNodeClass(key, value);\n            this._root._color = 0 /* TreeNodeColor.BLACK */;\n            this._root._parent = this._header;\n            this._header._parent = this._root;\n            this._header._left = this._root;\n            this._header._right = this._root;\n            return;\n        }\n        var curNode;\n        var minNode = this._header._left;\n        var compareToMin = this._cmp(minNode._key, key);\n        if (compareToMin === 0) {\n            minNode._value = value;\n            return;\n        }\n        else if (compareToMin > 0) {\n            minNode._left = new this._TreeNodeClass(key, value);\n            minNode._left._parent = minNode;\n            curNode = minNode._left;\n            this._header._left = curNode;\n        }\n        else {\n            var maxNode = this._header._right;\n            var compareToMax = this._cmp(maxNode._key, key);\n            if (compareToMax === 0) {\n                maxNode._value = value;\n                return;\n            }\n            else if (compareToMax < 0) {\n                maxNode._right = new this._TreeNodeClass(key, value);\n                maxNode._right._parent = maxNode;\n                curNode = maxNode._right;\n                this._header._right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    var iterNode = hint._node;\n                    if (iterNode !== this._header) {\n                        var iterCmpRes = this._cmp(iterNode._key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode._value = value;\n                            return;\n                        }\n                        else /* istanbul ignore else */ if (iterCmpRes > 0) {\n                            var preNode = iterNode._pre();\n                            var preCmpRes = this._cmp(preNode._key, key);\n                            if (preCmpRes === 0) {\n                                preNode._value = value;\n                                return;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new this._TreeNodeClass(key, value);\n                                if (preNode._right === undefined) {\n                                    preNode._right = curNode;\n                                    curNode._parent = preNode;\n                                }\n                                else {\n                                    iterNode._left = curNode;\n                                    curNode._parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this._root;\n                    while (true) {\n                        var cmpResult = this._cmp(curNode._key, key);\n                        if (cmpResult > 0) {\n                            if (curNode._left === undefined) {\n                                curNode._left = new this._TreeNodeClass(key, value);\n                                curNode._left._parent = curNode;\n                                curNode = curNode._left;\n                                break;\n                            }\n                            curNode = curNode._left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode._right === undefined) {\n                                curNode._right = new this._TreeNodeClass(key, value);\n                                curNode._right._parent = curNode;\n                                curNode = curNode._right;\n                                break;\n                            }\n                            curNode = curNode._right;\n                        }\n                        else {\n                            curNode._value = value;\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        this._length += 1;\n        return curNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._findElementNode = function (curNode, key) {\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return curNode || this._header;\n    };\n    TreeContainer.prototype.clear = function () {\n        this._length = 0;\n        this._root = undefined;\n        this._header._parent = undefined;\n        this._header._left = this._header._right = undefined;\n    };\n    /**\n     * @description Update node's key by iterator.\n     * @param iter - The iterator you want to change.\n     * @param key - The key you want to update.\n     * @returns Whether the modification is successful.\n     * @example\n     * const st = new orderedSet([1, 2, 5]);\n     * const iter = st.find(2);\n     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n     */\n    TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        if (this._length === 1) {\n            node._key = key;\n            return true;\n        }\n        if (node === this._header._left) {\n            if (this._cmp(node._next()._key, key) > 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        if (node === this._header._right) {\n            if (this._cmp(node._pre()._key, key) < 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        var preKey = node._pre()._key;\n        if (this._cmp(preKey, key) >= 0)\n            return false;\n        var nextKey = node._next()._key;\n        if (this._cmp(nextKey, key) <= 0)\n            return false;\n        node._key = key;\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByPos = function (pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var index = 0;\n        var self = this;\n        this._inOrderTraversal(this._root, function (curNode) {\n            if (pos === index) {\n                self._eraseNode(curNode);\n                return true;\n            }\n            index += 1;\n            return false;\n        });\n        return this._length;\n    };\n    /**\n     * @description Remove the element of the specified key.\n     * @param key - The key you want to remove.\n     * @returns Whether erase successfully.\n     */\n    TreeContainer.prototype.eraseElementByKey = function (key) {\n        if (this._length === 0)\n            return false;\n        var curNode = this._findElementNode(this._root, key);\n        if (curNode === this._header)\n            return false;\n        this._eraseNode(curNode);\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByIterator = function (iter) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        var hasNoRight = node._right === undefined;\n        var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n        // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n        if (isNormal) {\n            // So we should move it to next when it's right is null.\n            if (hasNoRight)\n                iter.next();\n        }\n        else {\n            // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n            // So when it has right, or it is a leaf node we should move it to `next`.\n            if (!hasNoRight || node._left === undefined)\n                iter.next();\n        }\n        this._eraseNode(node);\n        return iter;\n    };\n    TreeContainer.prototype.forEach = function (callback) {\n        var e_1, _a;\n        var index = 0;\n        try {\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var element = _c.value;\n                callback(element, index++, this);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    TreeContainer.prototype.getElementByPos = function (pos) {\n        var e_2, _a;\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var res;\n        var index = 0;\n        try {\n            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var element = _c.value;\n                if (index === pos) {\n                    res = element;\n                    break;\n                }\n                index += 1;\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n        return res;\n    };\n    /**\n     * @description Get the height of the tree.\n     * @returns Number about the height of the RB-tree.\n     */\n    TreeContainer.prototype.getHeight = function () {\n        if (this._length === 0)\n            return 0;\n        var traversal = function (curNode) {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n        };\n        return traversal(this._root);\n    };\n    return TreeContainer;\n}(Container));\nexport default TreeContainer;\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected readonly _eraseNode: (curNode: TreeNode<K, V>) => void;\n  /**\n   * @internal\n   */\n  protected _set: (key: K, value: V, hint?: TreeIterator<K, V>) => number;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    if (enableIndex) {\n      this._TreeNodeClass = TreeNodeEnableIndex;\n      this._set = function (key, value, hint) {\n        const curNode = this._preSet(key, value, hint);\n        if (curNode) {\n          let p = curNode._parent as TreeNodeEnableIndex<K, V>;\n          while (p !== this._header) {\n            p._subTreeSize += 1;\n            p = p._parent as TreeNodeEnableIndex<K, V>;\n          }\n          const nodeList = this._insertNodeSelfBalance(curNode);\n          if (nodeList) {\n            const {\n              parentNode,\n              grandParent,\n              curNode\n            } = nodeList as unknown as Record<string, TreeNodeEnableIndex<K, V>>;\n            parentNode._recount();\n            grandParent._recount();\n            curNode._recount();\n          }\n        }\n        return this._length;\n      };\n      this._eraseNode = function (curNode) {\n        let p = this._preEraseNode(curNode) as TreeNodeEnableIndex<K, V>;\n        while (p !== this._header) {\n          p._subTreeSize -= 1;\n          p = p._parent as TreeNodeEnableIndex<K, V>;\n        }\n      };\n    } else {\n      this._TreeNodeClass = TreeNode;\n      this._set = function (key, value, hint) {\n        const curNode = this._preSet(key, value, hint);\n        if (curNode) this._insertNodeSelfBalance(curNode);\n        return this._length;\n      };\n      this._eraseNode = this._preEraseNode;\n    }\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _preEraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return this._header;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      [curNode._key, swapNode._key] = [swapNode._key, curNode._key];\n      [curNode._value, swapNode._value] = [swapNode._value, curNode._value];\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    const _parent = swapNode._parent!;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    return _parent;\n  }\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    curNode: TreeNode<K, V> | undefined,\n    callback: (curNode: TreeNode<K, V>) => boolean\n  ): boolean {\n    if (curNode === undefined) return false;\n    const ifReturn = this._inOrderTraversal(curNode._left, callback);\n    if (ifReturn) return true;\n    if (callback(curNode)) return true;\n    return this._inOrderTraversal(curNode._right, callback);\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) curNode._left._parent = parentNode;\n          if (curNode._right) curNode._right._parent = grandParent;\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n          return { parentNode, grandParent, curNode };\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) curNode._left._parent = grandParent;\n          if (curNode._right) curNode._right._parent = parentNode;\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n          return { parentNode, grandParent, curNode };\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n        }\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _preSet(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value);\n      this._root._color = TreeNodeColor.BLACK;\n      this._root._parent = this._header;\n      this._header._parent = this._root;\n      this._header._left = this._root;\n      this._header._right = this._root;\n      return;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return;\n            }\n          }\n        }\n      }\n    }\n    this._length += 1;\n    return curNode;\n  }\n  /**\n   * @internal\n   */\n  protected _findElementNode(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    if (node === this._header._left) {\n      if (this._cmp(node._next()._key!, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (node === this._header._right) {\n      if (this._cmp(node._pre()._key!, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (this._cmp(preKey, key) >= 0) return false;\n    const nextKey = node._next()._key!;\n    if (this._cmp(nextKey, key) <= 0) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let index = 0;\n    const self = this;\n    this._inOrderTraversal(\n      this._root,\n      function (curNode) {\n        if (pos === index) {\n          self._eraseNode(curNode);\n          return true;\n        }\n        index += 1;\n        return false;\n      });\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._findElementNode(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  forEach(callback: (element: K | [K, V], index: number, tree: TreeContainer<K, V>) => void) {\n    let index = 0;\n    for (const element of this) callback(element, index++, this);\n  }\n  getElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    let res;\n    let index = 0;\n    for (const element of this) {\n      if (index === pos) {\n        res = element;\n        break;\n      }\n      index += 1;\n    }\n    return <K | [K, V]>res;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    const traversal =\n      function (curNode: TreeNode<K, V> | undefined): number {\n        if (!curNode) return 0;\n        return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n      };\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n"]},"metadata":{},"sourceType":"module"}